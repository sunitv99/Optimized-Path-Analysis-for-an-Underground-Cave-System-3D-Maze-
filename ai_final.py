# -*- coding: utf-8 -*-
"""AI_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10c5bg6lr-m2KXAiA0Muh84C8Yn0BJij9
"""
import time
start_time = time.time()
d={}
visited = {}
with open('input38.txt') as fp:
  algo = fp.readline().strip()
  # algo = "BFS"
  # algo = "UCS"
  # algo = "A*"
  limit = fp.readline().strip().split(" ")
  for i in range(len(limit)):
    limit[i]=int(limit[i])
  limit=tuple(limit)
  # limit = (8,0,1)
  start = fp.readline().strip().split(" ")
  for i in range(len(start)):
    start[i]=int(start[i])
  start=tuple(start)
  end = fp.readline().strip().split(" ")
  for i in range(len(end)):
    end[i]=int(end[i])
  end=tuple(end)
  # end=(1,3,2)
  noofactions = int(fp.readline().strip())
  print(algo)
  print(limit)
  print(start)
  print(end)
  print(noofactions)
  for i in range(noofactions):
    line = fp.readline().strip()
    # print(line)
    l=line.split(" ")[0:3]
    for i in range(len(l)):
      l[i]=int(l[i])
    a=line.split(" ")[3:]
    for i in range(len(a)):
      a[i]=int(a[i])
    l=tuple(l)
    d[l]=a
    visited[l]=0
    # print(l)
    # print(a)

d

visited

def p1(t):
  t[0]=t[0]+1
  return t
def p2(t):
  t[0]=t[0]-1
  return t
def p3(t):
  t[1]=t[1]+1
  return t
def p4(t):
  t[1]=t[1]-1
  return t
def p5(t):
  t[2]=t[2]+1
  return t
def p6(t):
  t[2]=t[2]-1
  return t
def p7(t):
  t[0]=t[0]+1
  t[1]=t[1]+1
  return t
def p8(t):
  t[0]=t[0]+1
  t[1]=t[1]-1
  return t
def p9(t):
  t[0]=t[0]-1
  t[1]=t[1]+1
  return t
def p10(t):
  t[0]=t[0]-1
  t[1]=t[1]-1
  return t
def p11(t):
  t[0]=t[0]+1
  t[2]=t[2]+1
  return t
def p12(t):
  t[0]=t[0]+1
  t[2]=t[2]-1
  return t
def p13(t):
  t[0]=t[0]-1
  t[2]=t[2]+1
  return t
def p14(t):
  t[0]=t[0]-1
  t[2]=t[2]-1
  return t
def p15(t):
  t[1]=t[1]+1
  t[2]=t[2]+1
  return t
def p16(t):
  t[1]=t[1]+1
  t[2]=t[2]-1
  return t
def p17(t):
  t[1]=t[1]-1
  t[2]=t[2]+1
  return t
def p18(t):
  t[1]=t[1]-1
  t[2]=t[2]-1
  return t

codes={
    1: p1,
    2: p2,
    3: p3,
    4: p4,
    5: p5,
    6: p6,
    7: p7,
    8: p8,
    9: p9,
    10: p10,
    11: p11,
    12: p12,
    13: p13,
    14: p14,
    15: p15,
    16: p16,
    17: p17,
    18: p18,
}
codes

def withinLimit(t):
  if t[0]>=limit[0] or t[0]<0 or t[1]>=limit[1] or t[1]<0 or t[2]>=limit[2] or t[2]<0:
    return False
  else:
    return True

from collections import defaultdict
def BFS(start):
  queue = []
  queued = {}
  queue.append(start)
  f=0
  if not withinLimit(start):
    print("Not Within Limit")
    return {}
  if start==end:
    return {start:0}
  while queue:
    current = queue.pop(0)
    if current in d and visited[current]==0:
      visited[current]=1
      # temp=[]
      for i in range(len(d[current])):
        t=tuple(codes[d[current][i]](list(current)))
        # print(t)
        # print(queued)
        if withinLimit(t) and t not in queued and visited[t]==0:
          # print(current,t)
          queued[t]=current
          queue.append(t)   
        if t==end:
          f=1
          return queued
  if f==0:
    return {}

def print_BFS(ans):
  f = open("output.txt","w")
  if ans==[]:
    f.write("FAIL")
  else:
    cost = len(ans)-1
    f.write(str(cost)+"\n")
    n=len(ans)
    f.write(str(n)+"\n")
    if n==1:
      f.write(str(start[0])+" "+str(start[1])+" "+str(start[2])+" "+"0")
    else:    
      f.write(str(start[0])+" "+str(start[1])+" "+str(start[2])+" "+"0"+"\n")
    for i in range(1,len(ans)):
      if i==(len(ans)-1):
        f.write(str(ans[i][0])+" "+str(ans[i][1])+" "+str(ans[i][2])+" "+"1")
      else:
        f.write(str(ans[i][0])+" "+str(ans[i][1])+" "+str(ans[i][2])+" "+"1"+"\n")

import math
def heuristic(t):
  dist = math.sqrt(abs(t[0]-end[0])**2 + abs(t[1]-end[1])**2 + abs(t[1]-end[1])**2)
  return dist

import heapq
from heapq import heappush
from heapq import heappop
def UCS(start):
  queue = []
  queued = {}
  cost = 0
  costfl=[0]
  costl=[0]
  costdict={start:0}
  cnt = 1
  f=0
  # cntr=0
  heappush(queue, [cost, cnt, start, costl])
  costf=99999999999999
  if not withinLimit(start):
    print("Node Not Within Limit")
    return [0,[0],{}]
  if start==end:
    return [0,costfl,{start:0}]
  while queue:
    c = heappop(queue)
    cost = c[0]
    current = c[2]
    costl= c[3]
    # print(cost,current,path)
    if current in costdict and costdict[current]<cost:
      continue
    if current == end and costf>=cost1:
      f=1
      costf=cost
      costfl=costl.copy()
      return [costf,costfl,queued]
    if current in d and visited[current]==0:
      visited[current]=1
      for i in range(len(d[current])):
        t=tuple(codes[d[current][i]](list(current)))
        if d[current][i]>=0 and d[current][i]<=6:
          c1=cost+10
        if d[current][i]>6 and d[current][i]<=18:
          c1=cost+14
        if t in queued and costdict[t]>c1:
          cl2=costl.copy()
          if d[current][i]>=0 and d[current][i]<=6:
            cl2.append(10)
          else:
            cl2.append(14)
          cnt+=1
          costdict[t]=c1
          heappush(queue,[c1,cnt,t,cl2])
        if withinLimit(t) and t not in queued and visited[t]==0:
          queued[t]=current
          cl=costl.copy()
          if d[current][i]>=0 and d[current][i]<=6:
            cost1 = cost + 10
            cl.append(10)
          else:
            cost1 = cost + 14
            cl.append(14)
          # print(t,cost1)
          # print(t,path,p)
          costdict[t]=cost1
          cnt+=1
          heappush(queue, [cost1, cnt, t, cl])
        # path.append(t)
        # addEdge(current,t)
        # if t == end and costf>=cost1:
        #   print("Node Found")
        #   f=1
        #   # cntr+=1
        #   costf=cost1
        #   costfl=cl.copy()
  # print(cntr)
  if f==0:
    return [0,[0],{}]
  # return [costf,costfl,queued]

def print_UCS_Astar(costf,pathf,costlist):
  f = open("output.txt","w")
  if pathf==[]:
    f.write("FAIL")
  else:
    f.write(str(costf)+"\n")
    n=len(pathf)
    f.write(str(n)+"\n")
    # f.write(str(start[0])+" "+str(start[1])+" "+str(start[2])+" "+"0"+"\n")
    for i in range(len(pathf)):
      if i==(len(pathf)-1):
        f.write(str(pathf[i][0])+" "+str(pathf[i][1])+" "+str(pathf[i][2])+" "+str(costlist[i]))
      else:
        f.write(str(pathf[i][0])+" "+str(pathf[i][1])+" "+str(pathf[i][2])+" "+str(costlist[i])+"\n")

def Astar(start):
  queue = []
  queued = {}
  cost = 0
  costl=[0]
  costfl=[0]
  cnt = 1
  ascore = heuristic(start)
  f=0
  costf=99999999999999
  heappush(queue, [ascore, cnt, start, cost, costl])
  if not withinLimit(start):
    print("Node Not Within Limit")
    return [0,[0],{}]
  if start==end:
    return [0,costfl,{start:0}]
  while queue:
    c = heappop(queue)
    ascore = c[0]
    cost = c[3]
    current = c[2]
    costl= c[4]
    # print(current)
    if current == end and costf>=cost1:
      f=1
      costf=cost
      costfl=costl.copy()
      return [costf,costfl,queued]
    # print(cost,current,path)
    if current in d and visited[current]==0:
      visited[current]=1
      for i in range(len(d[current])):
        t=tuple(codes[d[current][i]](list(current)))
        if withinLimit(t) and t not in queued and visited[t]==0:
          queued[t]=current
          cl=costl.copy()
          if d[current][i]>=0 and d[current][i]<=6:
            cost1 = cost + 10
            cl.append(10)
          else:
            cost1 = cost + 14
            cl.append(14)
          # p=path.copy()
          # p.append(t)
          # print(t,cost1)
          # print(t,path,p)
          cnt+=1
          ascore1 = cost1 + heuristic(t)
          heappush(queue, [ascore1, cnt, t, cost1, cl])
        # path.append(t)
        # addEdge(current,t)
        # if t == end and costf>=cost1:
        #   f=1
        #   costf=cost1
        #   costfl=cl.copy()
  if f==0:
    return [0,[0],{}]
  return [costf,costfl,queued]

if algo == "BFS":
  finalparent = BFS(start)
  finalparent = dict(finalparent)
  if finalparent=={}:
    ans=[]
  else:
    if start==end:
      ans = [start]
    else:
      current=end
      ans = [current]
      while current!=start:
        ans.append(finalparent[current])
        current=finalparent[current]
      ans=ans[::-1]
  print_BFS(ans)
if algo == "UCS":
  costf,costlist,finalparent = UCS(start)
  if finalparent=={}:
    pathf=[]
  else:
    if start==end:
      pathf = [start]
    else:
      current=end
      pathf = [current]
      while current!=start:
        pathf.append(finalparent[current])
        current=finalparent[current]
      pathf=pathf[::-1]
  print_UCS_Astar(costf,pathf,costlist)
if algo == "A*":
  costf,costlist,finalparent = Astar(start)
  if finalparent=={}:
    pathf=[]
  else:
    if start==end:
      pathf = [start]
    else:
      current=end
      pathf = [current]
      while current!=start:
        pathf.append(finalparent[current])
        current=finalparent[current]
      pathf=pathf[::-1]
  print_UCS_Astar(costf,pathf,costlist)

end_time = time.time()
print(end_time-start_time)